ransha
Ran Shaham (203781000)
EX: 2

FILES:
README		-- This file
uthreads.cpp	-- My implementation of the uthreads library.
uthread.h	-- A class definition of a uthread object.
uthread.cpp	-- The uthread class implementation. 
Makefile 	-- a makefile that creates the library (make with no arguments,
 		   or 'all')

__Part_1_Notes__

__Part_2_Answers__

_q_1_

The advantages of creating multiple processes instead of kernel-level
threads are (for web-browser tabs):
* If one tab crashes it crashes its process, which runs only that tab.
  If threads were used instead, all tabs were affected by one tab's crash
  since they share the same process. There are some solutions for that
  (try..catch for example) but they're more expensive to run.
* Each process gets its share of resources from the OS. On the other hand,
  threads share their process resources. When each tab gets a process there
  is no race for resources between tabs.

Some disadvantages:
* As seen in class, the context switch between processes is much more expensive
  than between threads since there is more data to handle (PCB has more data).
  So if we want several pages (tabs) to run concurrently for some reason, more
  time will be spent on context switching than in kernel-threads method
  (bigger overhead).
* I'm not a web-browser developer, but I guess tabs need to sometimes interact
  with each-other (e.g. the main browser process needs to know the name of
  the sites each tab runs to display the tab title, or needs to tell a tab
  we're not currently in to stop). Communication between processes, as seen
  in lectures and TAs, is more complicated than threads communication, since
  threads share resources and process usually don't.

_q_2_

_q_3_
Real time, as suggested by its name, counts the real time that has passed.
Virtual time, on the other hand, counts the time that has passed while 
executing the process - i.e it does not include the time that passed if the
OS switched to another process and ran it.
Thus it is clear that for each process that counts time: 
virtual_time <= real_time.
For example, if we want to write a program that tests reaction times of human
beings to a visual stimulus we should use 'Real time', since we want to
measure the real time that passed between displaying the stimulus and the
reaction. We don't care if during that time 30 other processes ran.
A good example for using virtual time is the current exercise - we want each
thread to get the same amount of time running code, and avoid 'unlucky' threads
that the os ran other processes on their share of run-time.

_q_4_
a. 
b.
